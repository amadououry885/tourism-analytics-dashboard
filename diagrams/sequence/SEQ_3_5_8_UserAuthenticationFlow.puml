@startuml User Authentication Flow Sequence

title Figure 3.15: User Authentication Sequence

skinparam backgroundColor #FEFEFE
skinparam sequenceArrowThickness 2
skinparam roundcorner 10

actor "User" as U #LightBlue
participant "Frontend\n(React)" as FE #E3F2FD
participant "Auth Context\n(React State)" as CTX #BBDEFB
participant "Axios Interceptor\n(API Client)" as AX #C8E6C9
participant "Backend\n(Django REST)" as BE #E8F5E9
participant "SimpleJWT\n(Token Service)" as JWT #FFF9C4
database "Database\n(PostgreSQL)" as DB #FFF3E0

== Initial Page Load ==

U -> FE: Access application
FE -> CTX: Check for stored tokens\n(localStorage)
CTX -> CTX: tokens = localStorage.getItem('tokens')

alt Tokens Exist
    CTX -> CTX: Parse stored tokens
    CTX -> CTX: Check token expiry
    
    alt Access Token Valid
        CTX --> FE: User authenticated (from cache)
        FE --> U: Show authenticated UI
    else Access Token Expired
        CTX -> AX: Attempt token refresh
        note right: Jump to "Token Refresh" section
    end
else No Tokens
    CTX --> FE: User not authenticated
    FE --> U: Show login page
end

== User Login ==

U -> FE: Enter credentials:\n- Username/Email\n- Password
FE -> FE: Client-side validation

FE -> AX: POST /api/auth/login/\n{username, password}
AX -> BE: Forward request

BE -> BE: Log: "Login attempt with: {username}"

BE -> DB: SELECT * FROM users\nWHERE username={username}\nOR email={username}
DB --> BE: User record (or null)

alt User Not Found
    BE -> BE: Log: "User not found"
    BE --> AX: 401 Unauthorized\n{error: "Invalid credentials"}
    AX --> FE: Login failed
    FE --> U: "Invalid username or password"
    
else User Found
    BE -> BE: Verify password:\ncheck_password(input, user.password)
    
    alt Password Invalid
        BE -> BE: Log: "Invalid password"
        BE --> AX: 401 Unauthorized\n{error: "Invalid credentials"}
        AX --> FE: Login failed
        FE --> U: "Invalid username or password"
        
    else Password Valid
        BE -> BE: Log: "Found user: {username}, is_active={status}"
        
        alt User Inactive
            BE --> AX: 401 Unauthorized\n{error: "Account disabled"}
            AX --> FE: Account disabled
            FE --> U: "Your account has been disabled"
            
        else User Active
            BE -> BE: Check approval status\n(for vendor/stay_owner roles)
            
            BE -> JWT: Generate tokens for user
            JWT -> JWT: Create access token:\n{user_id, username, role, exp: +5h}
            JWT -> JWT: Create refresh token:\n{user_id, exp: +1d}
            JWT --> BE: {access, refresh}
            
            BE -> BE: Log: "Login successful for: {username}"
            
            BE --> AX: 200 OK\n{access: "eyJ...",\nrefresh: "eyJ...",\nuser: {id, username, email,\nrole, is_approved}}
            
            AX --> FE: Login successful
            
            FE -> CTX: Store tokens and user data
            CTX -> CTX: localStorage.setItem('tokens',\n{access, refresh})
            CTX -> CTX: setUser(userData)
            
            FE --> U: Redirect to Dashboard\n(based on role)
        end
    end
end

== Authenticated API Request ==

U -> FE: Perform action requiring auth
FE -> AX: GET /api/vendors/my-profile/

AX -> AX: Intercept request
AX -> CTX: Get access token
CTX --> AX: access_token

AX -> AX: Add Authorization header:\n"Bearer {access_token}"

AX -> BE: GET /api/vendors/my-profile/\nAuthorization: Bearer eyJ...

BE -> JWT: Validate token
JWT -> JWT: Decode and verify signature
JWT -> JWT: Check expiration

alt Token Valid
    JWT --> BE: Token valid, user_id={id}
    BE -> DB: Fetch requested data
    DB --> BE: Data
    BE --> AX: 200 OK {data}
    AX --> FE: Response data
    FE --> U: Display data
    
else Token Invalid/Expired
    JWT --> BE: Token validation failed
    BE --> AX: 401 Unauthorized\n{error: "Token invalid or expired"}
    AX -> AX: Trigger token refresh
    note right: Continue to "Token Refresh"
end

== Token Refresh ==

AX -> AX: Intercept 401 response
AX -> CTX: Get refresh token
CTX --> AX: refresh_token

AX -> BE: POST /api/auth/token/refresh/\n{refresh: "eyJ..."}

BE -> JWT: Validate refresh token
JWT -> JWT: Decode and verify

alt Refresh Token Valid
    JWT -> JWT: Generate new access token
    JWT --> BE: {access: "eyJ_new_..."}
    
    BE --> AX: 200 OK {access: "eyJ_new_..."}
    
    AX -> CTX: Update stored access token
    CTX -> CTX: localStorage.setItem('tokens',\n{access: new_token, refresh})
    
    AX -> AX: Retry original request\nwith new token
    AX -> BE: Retry: GET /api/vendors/my-profile/\nAuthorization: Bearer eyJ_new_...
    BE --> AX: 200 OK {data}
    AX --> FE: Response data
    FE --> U: Display data (seamless)
    
else Refresh Token Invalid/Expired
    JWT --> BE: Refresh token invalid
    BE --> AX: 401 Unauthorized\n{error: "Refresh token expired"}
    
    AX -> CTX: Clear all tokens
    CTX -> CTX: localStorage.removeItem('tokens')
    CTX -> CTX: setUser(null)
    
    AX --> FE: Session expired
    FE --> U: Redirect to login page\n"Session expired. Please login again."
end

== User Logout ==

U -> FE: Click "Logout"
FE -> CTX: Trigger logout

CTX -> CTX: Clear localStorage:\nlocalStorage.removeItem('tokens')
CTX -> CTX: Clear user state:\nsetUser(null)

FE -> AX: Clear Authorization header
AX -> AX: Remove default header

FE --> U: Redirect to login page\n"Logged out successfully"

== Role-Based Access Check ==

note over FE, BE: After successful login,\nfrontend routes based on role

FE -> CTX: Get user role
CTX --> FE: role = "vendor"

alt role === "admin"
    FE --> U: Redirect to /admin/dashboard
else role === "vendor"
    alt is_approved === true
        FE --> U: Redirect to /vendor/dashboard
    else is_approved === false
        FE --> U: Show "Pending Approval" page
    end
else role === "stay_owner"
    alt is_approved === true
        FE --> U: Redirect to /stays/dashboard
    else is_approved === false
        FE --> U: Show "Pending Approval" page
    end
else role === "place_owner"
    FE --> U: Redirect to /places/dashboard
end

@enduml
